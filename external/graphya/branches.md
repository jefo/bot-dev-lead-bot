У тебя базовый кирпич — триплет (subject → predicate → object). Это чистая реляция. Чтобы на уровне бизнес-логики появилось что-то вроде "ветки" (branch), нужно ввести агрегацию триплетов в последовательность.

Разберём по шагам:

1. Базовый уровень — триплеты
(A) --p1--> (B)
(B) --p2--> (C)
(C) --p3--> (D)


Каждый триплет живёт сам по себе. У тебя ещё нет понятия "ветки".

2. Ветка как путь (path)

Ветка может определяться как упорядоченное множество триплетов, где object предыдущего = subject следующего.

[A -p1-> B -p2-> C -p3-> D]


То есть branch = [t1, t2, t3, ...].
Это не новая сущность в хранилище, а derived structure — собирается на лету при обходе.

3. Ветка как сущность бизнес-логики

Чтобы можно было ссылаться на ветку как на самостоятельную ноду (например, для документов), вводится мета-нода BranchId, которая описывает:

стартовую ноду,

стратегию обхода (правила включения связей),

конечные условия.

Пример триплета для этого:

(Branch#1) --start--> (A)
(Branch#1) --rule--> (predicate = p1|p2|p3)
(Branch#1) --end--> (D)

4. Ответвления

Теперь, если у тебя на одной ноде несколько исходящих рёбер, это даёт fork.
Пример:

(B) --p2--> (C)
(B) --p4--> (X)


То есть от ветки [A→B] отходят две подветки: [B→C] и [B→X].

Бизнес-логически можно сказать:

branch = путь,

branchPoint = нода, где происходит разветвление,

subbranch = продолжение от branchPoint.

5. Для документов с вставками

Если твоя цель — вставки из других документов, то модель выглядит так:

Ветка = последовательность сегментов документа (кусочков контента).

Разветвление = альтернатива вставки (например, один и тот же раздел можно собрать из разных источников).

Ветка может иметь идентификатор, чтобы на неё можно было сослаться в другом документе.

✅ Итого:

технически ветка = упорядоченное множество триплетов;

бизнес-логически ветка = сущность с ID + набором правил обхода (path definition);

разветвления реализуются естественно: любая нода может быть branchPoint с множеством исходящих рёбер.
